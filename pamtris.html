<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD><TITLE>Pamtris User Manual</TITLE></HEAD>
<BODY>

<H1>pamtris</H1>
Updated: 21 September 2018
<BR>
<A HREF="#index">Table Of Contents</A>

<H2>NAME</H2>
pamtris - triangle rasterizer featuring linear interpolation of generic
vertex attributes and depth buffering

<H2 id="synopsis">SYNOPSIS</H2>

<B>pamtris</B>

<B>-width=</B><I>width</I>

<B>-height=</B><I>height</I>

<B>-num_attribs=</B><I>attributes_per_vertex</I>

[<B>-maxval=</B><I>maxval</I>]

[<B>-tupletype=</B><I>tupletype</I>]

<P>All options can be abbreviated to their shortest unique prefix.
You may use two hyphens instead of one to designate an option.  You
may use either white space or an equals sign between an option name
and its value.</P>

<H2 id="description">DESCRIPTION</H2>

<p>This program is part of <a href="index.html">Netpbm</a>.

<p><b>pamtris</b> can be used to draw a great variety of 2D and 3D graphics by
composing arbitrarily complex pictures out of separate triangles, triangle
strips and triangle fans. The program reads instructions written in a simple
command script notation from Standard Input and outputs its results
as a (potentially multi-image) PAM stream on Standard Output.</p>

<p>For example, the following input

  <pre>
    <code>
      mode fan
      attribs 0 128 0
      vertex 0 0 1
      attribs 0 0 128
      vertex 200 0 1
      attribs 50 20 103
      vertex 190 61 1
      attribs 100 40 78
      vertex 161 117 1
      attribs 150 60 53
      vertex 117 161 1
      attribs 200 80 28
      vertex 61 190 1
      attribs 250 100 3
      vertex 0 200 1
      print
    </code>
  </pre>
  
  produces this:

<img src="pamtris_fan.png" alt="Example Pamtris output for fan mode"/>
  
<p>The input file gives triangle data by setting the appropriate drawing mode,
if necessary, and then providing a list of vertices. Each vertex is also
associated with a list of up to 20 &quot;attributes&quot;, which are integer
values between 0 and a given maxval. In the most common usage, you use
<b>pamtris</b> to draw a visual image and a vertex has three attributes, which
are an RGB specification of a color.  Such attribute lists may be provided on
a per-vertex basis.</p>

<p>The frame buffer consists of an "image buffer" and a "depth buffer". The
image buffer consists of a sequence of <i>height</i> rows containing a
sequence of <i>width</i> tuples. There is one sample in each tuple for each
vertex attribute plus an opacity (alpha) sample. Each tuple is associated with
an integer depth in the depth buffer, which determines whether subsequent
drawing operations affect that particular tuple or not. This provides a way of
depth-sorting graphical objects which is adequate for many purposes in 2D and
3D computer graphics. One prominent shortcomming of such an approach to
depth-sorting, however, is that it does not automatically work with objects
which are intended to appear "translucent," therefore requiring more elaborate
strategies to incorporate said objects into pictures generated using this
technique.</p>

<p>The opacity sample is the last sample of the tuple.  <b>pamtris</b>
manipulates opacity internally and it is always 0 or the maxval.  The program
does not provide the user direct control over the alpha image plane.

<p><b>pamtris</b> rasterizes triangles by approximating their visible area as
a collection of pixels at particular positions in the frame buffer, and to
every tuple it assigns a list of attributes whose values are a particular
linear interpolation between the values of the corresponding attributes of
each vertex of the triangle. Whenever a tuple within the area of the frame
buffer is produced, it is written only to the corresponding position in the
frame buffer if and only if it passes a depth test.  This test
works as follows: the depth value of every incoming tuple (which is itself a
linear interpolation between the Z-coordinates of the vertices of the
corresponding triangle) is compared against the value in the corresponding
position in the depth buffer. If the depth value of the incoming tuple
equals or is below the depth value already present in said position in the
depth buffer, the following happens:</p>

<ol>
<li>Every sample <i>i</i>, where 0 &#8804; <i>i</i> &lt; <i>num_attribs</i>,
of the tuple in the corresponding position in the image buffer is set to equal
the value of the respective attribute of the incoming tuple; and the alpha
sample (the last one) is updated to the <i>maxval</i>;</li>

<li>The depth value in the corresponding position in the depth buffer is
updated the depth value of the incoming tuple.</li>
</ol>

<p>Otherwise, that particular tuple effects no change at all in the frame
buffer.</p>

<p>The frame buffer is initially set so that all samples in every tuple of the
image buffer contain the value 0, and all entries in the depth buffer contain
the maximum permitted depth value.</p>

<p>The attributes' values, and therefore the samples in the output
PAM images, have no fixed interpretation ascribed to them (except for the
last image plane, which is deliberately supposed to represent tuple opacity
information): one may ascribe any suitable meaning to them, such as that of
colors, texture coordinates, surface normals, light interaction
characteristics, texture influence coefficients for multi-texturing, etc.</p>


<h2 id="examples">EXAMPLES</h2>

<h3 id="examples_fan">Fan Mode</h3>

<P>The following command generates the image from the fan mode example at the
top of the <a href="#description">DESCRIPTION</a> section.

<pre>
  <kbd>
    $ pamtris -num_attribs=3 -height=200 -width=200 -tupletype=RGB_ALPHA \
        &lt;fan.tris &gt;fan.pam
  </kbd>
</pre>
  
<h3 id="examples_strip">Strip Mode</h3>

<p>The following is an example of strip mode:

  <pre>
    <code>
      mode strip
      attribs 255 0 0   # red
      vertex   0 200 1
      vertex  50   0 1
      attribs 0 0 0     # black
      vertex 100 200 1
      attribs 0 205 205 # cyan
      vertex 150 0 1
      attribs 0 0 255   # blue
      vertex 200 200 1
      vertex 250   0 1
      print
    </code>
  </pre>

<p>Process with:
  
<pre>
  <kbd>
    $ pamtris -num_attribs=3 -height=200 -width=200 -tupletype=RGB_ALPHA
        &lt;strip.tris &gt;strip.pam
  </kbd>
</pre>
  
to yield:
<img src="pamtris_strip.png" alt="Example Pamtris output for strip mode"/>

<h3 id="examples_triangles">Triangle Mode</h3>

<p>The following is an example of triangle mode:

  <pre>
    <code>
      # yellow square
      mode strip
      attrib 155 155 0
      vertex 50  50 100
      vertex 50 200 100 
      vertex 200 50 100
      vertex 200 200 100
      
      # blue triangle
      mode triangles
      attrib 0 205 205
      vertex 20 125 70
      attrib 0 0 140
      vertex 230  70 120 # Change "120" and see what happens
      vertex 230 180 120 #
      print
    </code>
  </pre>

<p>Process with:
  
<pre>
  <kbd>
    $ pamtris -num_attribs=3 -height=200 -width=200 -tupletype=RGB_ALPHA
        &lt;pierce.tris &gt;pierce.pam
  </kbd>
</pre>
  
to yield:
<img src="pamtris_pierce.png" alt="Example Pamtris output for triangle mode"/>


<h3 id="pamtris_c">Meta-programming</h3>

<p>The <b>pamtris</b> command language is much too weak to do any serious
drawing; you will probably want to use a general purpose programming language
to generate a temporary <b>pamtris</b> command file.

<p>For example, the following C program generates <b>pamtris</b> instructions
to generate a picture of NAMCO's Pac-Man.  It generates hundreds of
<b>vertex</b> commands tracing around the perimeter of a circle.

<img alt="Pac-Man" src="pamtris_pacman.png">

<pre>
<code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define PI		3.141592
#define PI2		(2.0 * PI)

#define WIDTH		256
#define HEIGHT		WIDTH

#define SEGMENTS	(PI * WIDTH)

int main()
{
        int const center_x = 0.5 * WIDTH;
        int const center_y = 0.5 * HEIGHT;

        double const radius = 0.48 * WIDTH;

        puts("mode triangles");

        int const y_leg = tan(PI / 4.0) * center_x;

        printf("vertex %d %d 0\n", center_x, center_y);
        printf("vertex %d %d 0\n", WIDTH, center_y - y_leg);
        printf("vertex %d %d 0\n", WIDTH, center_y + y_leg);

        puts("clear image");
        puts("mode fan");
        puts("attribs 255 255 0");
        printf("vertex %d %d 1\n", center_x, center_y);
        puts("attribs 255 128 0");

        double const ang_step = PI2 / SEGMENTS;
        unsigned int i;
        double ang;

        for(i = 0, ang = 0.0; i &lt;= SEGMENTS; i++)
        {
                int const x = round(cos(ang) * radius + center_x);
                int const y = round(sin(ang) * radius + center_y);

                printf("vertex %d %d 1\n", x, y);

                ang += ang_step;
        }

        puts("print");

        return 0;
}
</code>
</pre>


<H2 id="options">OPTIONS</H2>

<DL COMPACT>
<DT><B>-width=</B><I>width</I></DT>
<DD>Sets the width of the internal framebuffer and, by extension, of the
output PAM images, given in number of columns. This must be an integer in the
closed interval [1, 8192].</DD>

<p>This option is mandatory.
  
<DT><B>-height=</B><I>height</I></DT>
<DD>Sets the height of the internal framebuffer and, by extension, of the
output PAM images, given in number of rows. This must also be an integer in
the closed interval [1, 8192].</DD>

<p>This option is mandatory.

<DT><B>-num_attribs=</B><I>attributes_per_vertex</I></DT>
<DD>Sets the number of attributes per vertex and, by extension, the depth of
the output PAM images, which is equal to this value plus one (to accomodate
the alpha plane). The argument must be an integer in the closed interval [1,
20].

<p>The input program may override this with a <b>reset</b> command.

<p>This option is mandatory.

<DT><B>-maxval=</B><I>maxval</I></DT>
<DD>Sets the maxval of the output PAM images, which is also the maximum
permitted value for each vertex attribute. This must be an integer in the
closed interval [1, 65535].

<p>The default value is 255.

<p>The input program  may override this with a <b>reset</b> command.

<DT><B>-tupletype=</B><I>tupletype</I></DT>
<DD>Sets the tupletype for the output PAM images. The argument is a string
which may be no longer than 255 characters.

<p>The input program may override this with a <b>reset</b> command.

<p>In the usual case that you are drawing a color visual image, specify
<b>RGB_ALPHA</b> for this.

<p>The default is a null string.

</DL>

<H2 id="instruction_code">INSTRUCTION CODE</H2>

<p>The input for <b>pamtris</b> consists of a sequence of text lines sent to
it through the standard input mechanism.</p>

<p>Empty lines or lines that contain only white space characters are called
blank lines and are ignored.</p>

<p>When a <b>#</b> occurs anywhere in a line, <b>pamtris</b> ignores it
along with every character after it. In other words, everything from the
<b>#</b> until the end of the line receives the same treatment as white
space.</p>

<p>Lines which are not blank must contain a sequence of strings separated by
white space, called tokens.  The first such token must be one of the
commands recognized by <b>pamtris</b>, and all further tokens are interpreted
as the arguments for that command, if it takes any. When an insufficient
number of arguments is provided for a command, the line is considered invalid
and is given the same treatment as a blank line. The same happens when an
out of range argument or one of a kind different of what is expected is given
(for example, when you give a string of letters where a numerical value is
expected), or when an unrecognized command/argument is found. When a number of
arguments greater than that required for a particular command is provided,
only the portion of the line up to the last required argument is considered
and any further tokens are ignored.</p>

<p><b>pamtris</b> is case-insensitive. That is, <b>mode</b>, <b>MODE</b>,
<b>mODe</b>, etc. are all treated the same way.</p>

<p>The commands recognized by <b>pamtris</b> are:</p>
<DL>
<DT><B>quit</B></DT>
<DT><B>mode</B></DT>
<DT><B>attribs</B></DT>
<DT><B>vertex</B></DT>
<DT><B>print</B></DT>
<DT><B>clear</B></DT>
<DT><B>reset</B></DT>
</DL>

<p>You may use a minimum unique abbreviation of a command name.  You may use
an exclamation mark (<b>!</b>) in place of the <b>print</b> command name an an
asterisk (<b>*</b>) in place of <b>clear</b>.

<p>The functions of the commands are as follows.

<DL>
<DT><B>quit</B></DT>
<DD>
<p>This terminates <b>pamtris</b>. The program will not read any more lines of
input when this command is found, and shall ignore any further tokens on the
same line as it.</p>
</DD>
<DT><B>mode</B> { triangles | strip | fan }</DT>
<DD>
<p>This makes <b>pamtris</b> enter a new drawing mode. The argument is a word
which specifies the mode to change to. Instead of a full argument name, it is
permissible to provide a minimum unique abbreviation, which has the same
effect. The drawing mode will remain the same until the next <b>mode</b>
command is given.</p>

<p>This command also resets the current vertex list, which is
(re)initialized to an empty state after the command is executed. One may add
new vertices to this list through successive invocations of the <b>vertex</b>
command (see below). You do not have to worry about providing "too many"
vertices, since the vertex list is virtualized: <b>pamtris</b> maintains only
the state pertaining to three vertices at any one time. The current vertex
list is initially empty.</p>

<p>It is permissible to give <b>pamtris</b> a <b>mode</b> command which
instructs it to enter a drawing mode it is currently already in. One might
use this approach to reset the current vertex list without changing the
current drawing mode.</p>

<p>Regardless of the current drawing mode, a new triangle is immediately
rasterized into the frame buffer as soon as the necessary vertices for it are
provided through the current vertex list.</p>

<p>In the following descriptions of each drawing mode, triangles' and
vertices' indices are 0-based.</p>

<p>The <b>triangles</b> argument instructs <b>pamtris</b> to enter the
"TRIANGLES" drawing mode. While in this mode, a series of separate triangles
is constructed. Every three vertices pushed into the current vertex list
specify a new triangle.  Formally, this means that every
<i>N<sup>th</sup></i> triangle is specified by vertices 3 * <i>N</i>, 3
+ <i>N</i> + 1, and 3 * <i>N</i> + 2. This is the default initial mode and is
therefore not required to be set explicitly before drawing any triangles.
</p>

<p>The <b>strip</b> argument instructs <b>pamtris</b> to enter the "STRIP"
drawing mode.  While in this mode, <b>pamtris</b> constructs a &quot;triangle
strip.&quot; That is, the first three vertices pushed into the current vertex
list specify the first triangle, and every new vertex pushed after that
specifies, together with the previous two, the next triangle. Formally, this
means that every <i>N</i><sup>th</sup> triangle is specified by vertices
<i>N</i>, <i>N</i> + 1, and <i>N</i> + 2.</p>

<p>The <b>fan</b> argument instructs <b>pamtris</b> to enter the "FAN" 
drawing mode.  While in this mode, a so-called "triangle fan" is constructed.
That is, the first three vertices pushed into the current vertex list specify
the first triangle, and every new vertex pushed after that specifies, together
with the previous vertex and the first one, the next triangle. Formally, this
means that every <i>N</i><sup>th</sup> triangle is specified by vertices
<i>0</i>, <i>N</i> + 1, and <i>N</i> + 2.</p> 
</DD>

<DT>
<B>attribs</B> <i>a<sub>0</sub></i> ... <i>a<sub>num_attribs - 1</sub></i>
</DT>
<DD>
<p>This updates the current attribute values list. This command takes as
arguments a sequence of <i>num_attribs</i> integers which represent the
values of the attributes to be associated with the next vertex. This
sequence of values is the just mentioned "current attribute values list".</p>

<p>Each <i>i<sup>th</sup></i> argument, where 0 &#8804; <i>i</i> &lt;
<i>num_attribs</i>, indicates the value to be assigned to the
<i>i</i><sup>th</sup> attribute of the current attribute values list. All
arguments must be integer values in the closed interval [0, <i>maxval</i>].
If a number of arguments less than the current value of <i>num_attribs</i>
is given, the command is considered invalid and is therefore ignored.</p>

<p>The current attribute values list remains unchanged until the next valid
<b>attribs</b> or <b>reset</b> command is given. The <b>attribs</b> command
allows one to change the values of each attribute individually, while the
<b>reset</b> command is not specifically designed for that function, but it
has the side effect of setting all values in the current attribute values
list to the <i>maxval</i> (see below).</p>

<p>All values in the current attribute values list are initially set to the
<i>maxval</i>.</p>
</DD>
<DT><B>vertex</B> <i>x</i> <i>y</i> <i>z</i> </DT>
<DD>
<p>Adds a new vertex to the current vertex list (see the <b>mode</b>
command above), assigning the values of the arguments to its respective
coordinates, and the values in the current attribute values list (see the
<b>attribs</b> command above) to the respective entries in the 
attribute list associated with the vertex.</p>

<p>The <i>x</i> and <i>y</i> arguments must be integer values in the
closed interval [-32767, 32767], and they represent, respectively, the
column and row of the tuple which corresponds to the location of the
vertex. Such values may correspond to tuples outside the limits of the
frame buffer. The origin of the coordinate system is at the top-left tuple
of the frame buffer. The X-axis goes from left to right, and the Y-axis
from top to bottom. A negative value for <i>x</i> indicates a column that
many tuples to the left of the leftmost column of the frame buffer.
Likewise, a negative value for <i>y</i> indicates a row that many tuples
above the uppermost row of the frame buffer.</p>

<p>The <i>z</i> argument represents the  Z-coordinate of the vertex, which
is used to compute depth values for tuples within the areas of rasterized
triangles. This must be an integer value in the closed interval
[0, 1073741823].</p>
</DD>
<DT><B>print</B></DT>
<DD>
<p>This appends a PAM image to standard output whose raster is a copy of the
current contents of the image buffer. The values of the WIDTH and HEIGHT
fields are the same as the width and height, respectively, of the frame
buffer, which were given on the command line during program invocation. The
MAXVAL field is equal to the current maxval; the DEPTH field is equal to
the current value of <i>num_attribs</i> + 1; and the TUPLTYPE field is
equal to the current tupletype.</p>

<p>This command has no effect upon the current drawing state. E. g. it does
not modify the current drawing mode, the current vertex list, etc.</p>
</DD>
<DT><B>clear</B> [ image | depth ]</DT>
<DD>
<p>Clears the frame buffer. That is, all samples in the image buffer are once
again set to 0, and all entries in the depth buffer are once again set to the
maximum permitted depth value.</p>

<p>Optionally, one may provide an argument to only clear either the image
buffer or the depth buffer individually, while leaving the other intact. With
the <b>image</b> argument, only the image buffer is cleared; with the
<b>depth</b> argument, only the depth buffer is cleared. Instead of full
argument names, one may provide a minimum unique abbreviation, which has the
same effect. The single character <b>z</b> is also accepted as an alias for
<b>depth</b>.</p>

<p>Like the <b>print</b> command, this command has no effect upon the
current drawing state either.</p>
</DD>
<DT><B>reset</B> <i>maxval</i> <i>num_attribs</i> [<i>tupletype</i>]</DT>
<DD>
<p>This updates the current maxval and number of attributes per vertex
(num_attribs), resetting the <u>image</u> buffer with a new maxval and number
of samples per tuple while at it. The parameter <i>maxval</i> must be an
integer in the closed interval [1, 65535], and <i>num_attribs</i> must be an
integer in the closed interval [1, 20].</p>

<p>Optionally, after the second argument, one may provide a string to be
assigned to the current <i>tupletype</i>. The string goes from the first
character after the second argument which is not white space and continues
until (and including) the last character before the end of the line which is
not white space.  If a new tupletype is not provided, or the provided string
is longer than 255 characters, the empty string is assigned to the current
<i>tupletype</i>.</p>

<p>The side effects of running this command are</p>

<ul>
<li>
The new image buffer is completely cleared once the command is executed.
</li>
<li>
All values in the current attribute values list are set to the new maxval.
</li>
<li>
The current vertex list is reset.
</li>
</ul>

<p>However, it does not touch the depth buffer: it is left the same way as it
was found before the command. Also the drawing mode remains the same (e. g. if
<b>pamtris</b> was in FAN mode, it will continue in that same mode, etc.).</p>

<p>If this command is given with an invalid value for <i>maxval</i> or
<i>num_attribs</i>, it is ignored and therefore none of the above side
effects apply, nor do the current maxval, num_attribs or tupletype change at
all.</p>

<p>It is permissible to give a value for <i>maxval</i> and <i>num_attribs</i>
equal to the current maxval and num_attribs, respectively, although the above
side effects will still apply even in such cases.</p>

<p>Since this command deals with memory allocation, it may fail to execute
successfully. If that happens, no lines of input will be read anymore and
<b>pamtris</b> will be terminated as if the <b>quit</b> command was given.</p>
</DD>
</DL>

<H2 id="tips">TIPS</H2>
<H3>Texturing</H3>

<p>It is possible to apply so-called "textures" to images produced with
<b>pamtris</b> by using a pair of vertex attributes as texture
coordinates, then using <a href="pamchannel.html"><b>pamchannel</b></a> to
select the appropriate channels in the output image(s), and finally
processing the result through <a href="pamlookup.html"><b>pamlookup</b></a>,
providing the desired texture file as a "lookup table". Textures applied
this way are naturally perspective-correct.</p>

<p>You might want to consider using
<a href="pnmtile.html"><b>pnmtile</b></a> to make textures which are
inteded to be "repeated" along triangle meshes.</p>

<H3>Anti-aliased edges</H3>

<p><b>pamtris</b> performs no anti-aliasing on triangle edges by itself.
However, it is possible to obtain anti-aliased images through a
&quot;super-sampling&quot; approach: draw your image(s) at a size larger than
the desired final size, and then, when all post-processing is done,
down-scale the final image(s) to the desired size.</p>

<p>Drawing images with twice the desired width and height, then down-scaling
them to the desired size using a quadratic filter, might produce results
which are often good enough. You might want to use
<a href="pamscale"><b>pamscale</b></a> for the down-scaling part, but if
that's not fast enough you might consider using another scaler. For example,
if you are piping frames into <b>ffmpeg</b> to make a movie out of them, you
might want to use its own scaler.</p>


<H2 id="seealso">SEE ALSO</H2>

<B><A HREF="pampick.html">pampick</A></B>
<B><A HREF="pamchannel.html">pamchannel</A></B>
<B><A HREF="pamstack.html">pamstack</A></B>
<B><A HREF="pamlookup.html">pamlookup</A></B>
<B><A HREF="pamarith.html">pamarith</A></B>
<B><A HREF="pamarith.html">pamscale</A></B>
<B><A HREF="pamdepth.html">pamdepth</A></B>
<B><A HREF="pamexec.html">pamexec</A></B>
<B><A HREF="pam.html">pam</A></B>

<H2 id="author">AUTHOR</H2>

<B>pamtris</B> was written by
<A HREF="mailto:lucaslunar32@hotmail.com">Lucas Brunno Luna</A>.
The author is grateful to Bryan Henderson for offering suggestions regarding
usability.

<H2 id="history">HISTORY</H2>

<p><b>pamtris</b> was new in Netpbm 10.84 (September 2018).

<HR>
<H2 id="index">Table Of Contents</H2>
<UL>
<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
<LI><A HREF="#description">DESCRIPTION</A></LI>
<LI><A HREF="#example">EXAMPLES</A></LI>
<ul>
  <LI><A HREF="#examples_fan">Fan Mode</A></LI>
  <LI><A HREF="#examples_fan">Strip Mode</A></LI>
  <LI><A HREF="#examples_fan">Triangle Mode</A></LI>
  <LI><A HREF="#examples_fan">Meta-programming</A></LI>
  </ul>
<LI><A HREF="#options">OPTIONS</A></LI>
<LI><A HREF="#instruction_code">INSTRUCTION CODE</A></LI>
<LI><A HREF="#tips">TIPS</A></LI>
<LI><A HREF="#seealso">SEE ALSO</A></LI>
<LI><A HREF="#author">AUTHOR</A></LI>
</UL>

</BODY>
</HTML>
